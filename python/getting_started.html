<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <meta content="" name="keywords">
    <meta content="" name="description">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&family=Ubuntu:wght@500;700&display=swap"
        rel="stylesheet">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.4.1/font/bootstrap-icons.css" rel="stylesheet">

    <link href="lib/animate/animate.min.css" rel="stylesheet">
    <link href="lib/owlcarousel/assets/owl.carousel.min.css" rel="stylesheet">

    <link href="css/bootstrap.min.css" rel="stylesheet">

    <link href="css/style.css" rel="stylesheet">
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
    <script defer src="https://pyscript.net/latest/pyscript.js"></script>
    <py-config>
        packages = ['numpy', 'matplotlib']
    </py-config>

</head>

<body style="background-color:lightslategray;">
    <h1 align="center">Getting started</h1>
    <br>
    <div align="center">
        <p>I'm going to begin with the go-to command that everyone is doing when
            they start with programming, that is "Hello world"
        </p>
        <p>HINT: To execute or run the following cell, you need to press Shift+Enter</p>
        <div align="left">
            <py-repl output-mode="replace">print("Hello world")</py-repl>
        </div>
        <p>And just like that, you've run your first python program.</p>
        <br>
        <p>Let's kick it up a notch and introduce variables. variables
            store information that is used later. It could be whole numbers,
            words(or strings), objects and so on.
        </p>
        <div align="left">
            <py-repl>
                a = 5
                print(a)
            </py-repl>
        </div>
        <p>This is almost self explanatory. We have the name of the variable on the left
            and we have the variable's value on the right. Now, the 'a' variable is holding
            the value 5, if you run the cell, you will see that 'a' will be equal to 5.
        </p>
        <br>
        <br>

        <p>I'm going to introduce the string. It's widely used to store some form
            of text data.
        </p>
        <div align="left">
            <py-repl>
                x = "hey there"
                print(x)
            </py-repl>
        </div>
        <br>
        <br>

        <p>Next, I'm going to introduce the Equal, Greater or Less than symbols.</p>
        <div align="left">
            <py-repl>a = 5
                b = 10
                if a < b: print("b is larger") </py-repl>
                    <br>
                    <br>
                    <p>You could probably tell what's going on here. If 'a' is less than 'b'
                        then print something to the screen. In this case, 'a' is less than 'b'
                        so, it's printing.
                    </p>
        </div>
        <br>
        <br>
        <p>I'm going to continue with the importat things for AI, numbers. Numbers could be
            int(whole), float(fractions), complex.
        </p>
        <div align="left">
            <py-repl>
                x = 1 # int
                y = 2.8 # float
                z = 1j # complex

                print(type(x))
                print(type(y))
                print(type(z))
            </py-repl>
            <br>
            <p>You could see that you can get the type of the variable by simply
                printing it to the page. This is very useful.
            </p>
            <br>
            <br>
            <br>
            <p>The next big thing is called casting. Whenever you feel appropriate
                to turn one variables' type into another, you could use casting.
                In the cell below I'm using it to turn the float variable 'a' to
                integer(whole number) and the integer variable 'b' to float number.
            </p>
            <div align="left">
                <py-repl>
                    a = 5.8
                    b = 5
                    print(int(a))
                    print(type(float(b)))
                </py-repl>
            </div>
            <br>
            <br>
            <br>
            <p>I'm going to skip ahead to some of the most useful stuff from now on.
                They are called lists and they contain information, just like the other
                types I've shown. The difference is that they could contain multiple variables
                in them. So, whenever they are printed or called, they usually contain more
                than one variable or value. Of course, they could hold nothing.
            </p>
            <div align="left">
                <py-repl>
                    a = [1,2,3]
                    a
                </py-repl>
                <p>But what happens when you decide to get only one of the values
                    inside the list? We have this thing called indexing and slicing.
                    Whenever you want to access a value in the list, you tell Python
                    at what index you want the value, and Python will get it for you
                    if this index exists.
                    <br>
                    REMEMBER: indexing starts at zero, so, the first element of the list
                    is at index 0.
                </p>
                <div align="left">
                    <py-repl>
                        a = [65,32,98]
                        b = a[0]
                        print(b)
                    </py-repl>
                    <p>As you can see, I got the first element by indexing.But what about
                        the other elements. For example the last element. It's not really convenient
                        to count all the variables until the last one, so Python made it really
                        handy to use [-1].
                    </p>
                    <div align="left">
                        <py-repl>
                            a = [65,32,98]
                            b = a[-1]
                            print(b)
                        </py-repl>
                    </div>
                    <p>I'm going to continue with the other very useful thing about Pythons' lists
                        and that is slicing. What if you want to take the values from the first index
                        until the third index. How are you going to get it. Python again made it very simple.
                    </p>
                    <div align="left">
                        <py-repl>
                            a = [65,32,92,33,712,10]
                            b = [1:3]
                        </py-repl>
                    </div>
                </div>
                <py-script>
                    import numpy as np
                    a = np.array([65,32,92,33,712,10])
                    b = [1:3]
                    print(b)
                </py-script>
                <p>As you can see, the values that are in the variable 'b' are from index 1 to index 3
                    not inclusive.
                </p>
                <br>
                <br>
                <p>Next, I'm going to utilise Pythons' functions over the lists. They are pretty useful in
                    some situations. This is a good place to introduce Numpy(or np). It's a numerical library
                    for python. It's the basis for some of the more complex tasks afterwards.
                </p>
                <div align="left">
                    <py-repl>
                        import numpy as np
                        a = [54,22,17,999, 56]
                        sorted(a)
                        #As you can see, by simply typing 'sorted' in front of the list sorts it.
                        #You can do the opposite by typing reverse after the variable's name.
                    </py-repl>
                    <py-repl>
                        a = [54,22,17,999, 56]
                        sorted(a, reverse=True)
                        #As you can see, it is as simple as that to reverse a list.
                    </py-repl>
                </div>
                <p>Different types:</p>
                <py-repl>
                    a = [12, 44, "apple", 43.3]
                    type(a[0]), type(a[1]), type(a[2]), type(a[3])
                </py-repl>
                <p>As is evident, you can have different types of variable in a single list.
                    It's convenient but as far as AI goes, the lists or should I say the majority of matrices 
                    will be with floats and integers.
                </p>
                <br>
                <br>
                <p>Summing list by scalar:</p>
                <py-repl>
                    a = [1,2,3,4,5]
                    b = 5
                    # a + b is not going to work with simple python list, the thing I'm after is 
                    # summing each and every number within the list with 'b' variable. For this cause
                    # I could use numpy!
                    import numpy as np
                    a = np.array([1,2,3,4,5])
                    a + 5
                </py-repl>
                <p>Multiplying list by scalar</p>
                <py-repl>
                    import numpy as np
                    a = np.array([1,2,3,4,5])
                    b = 5
                    c = a * b 
                    # I expect the result to be as follows: 5 to be multiplied with every single number of the list
                    # It is just that!
                    c
                </py-repl>
                <br>
                <br>
                <p>Iterating over lists:</p>
                <br>
                <p>Another thing that I'm going to use is iteration over a list. You've iterated in the cell before without knowing it.
                    Numpy knows what to do and it multiplies under the hood.
                </p>
                <py-repl>
                    import numpy as np
                    a = np.array([1,2,3,4,5])
                    b = 5 
                    c = a * b 
                    my_array = []
                    for number in a:
                        my_array.append(number * b)
                    c, my_array
                    # Yes, they are identical! So, either implicit or explicit multiplication or summation is used.
                    # Whatever you feel like it.
                </py-repl>
                <br>
                <br>
                <p>Dictionaries:</p>
                <py-repl>
                    a = dict()
                    a["ford"] = "mustang"
                    a["suzuki"] = "hayabusa"
                    a
                </py-repl>
                <p>It's very simple example. Just think of it as whenever you think of something, for example when you think of 
                    suzuki, you immediately associate hayabusa with it. Whenever you think of a airplane, you might think of Airbus or Boeing.
                </p>
                <br>
                <br>
                <p>If else, elif:</p>
                <p>These are at the core of the program logic flow. They are very intuitive and are used almost everywhere.</p>
                <py-repl>
                    a = 4
                    b = 10
                    c = ""
                    if a < b:
                        c = "b is bigger"
                    else:
                        c = "a is bigger"
                    c
                    
                </py-repl>
                <py-repl>
                    # I'm going to introduce the keyword elif. It's short for else if. 
                    z = 3
                    c = ""
                    if z % 2 == 0:
                        c = "z is divisible by 2"
                    elif z % 3 == 0:
                        c = "z is divisible by 3"
                    else:
                        c = "z is neither divisible by 2 nor by 3"
                    c
                </py-repl>
                <br>
                <br>
                <p>While loops:</p>
                <p>While loops are almost identical to for loops. The difference is if I don't 
                    stop the while loop, it could go on forever. Let's look at the example:
                </p>
                <py-repl>
                    # The simple explanation is: initialize count to 0 and then check every iteration 
                    # whether count is less than 10, it it's less than 10, increment it by one, if it's 
                    # 10, STOP.
                    count = 0
                    while count < 10:
                        count += 1
                    count
                </py-repl>
                <br>
                <br>
                <p>Functions:</p>
                <p>Functions are code that could be reused later in the code. They start with the keyword def 
                    {name of function} and then ':'. Let's see an example:
                </p>
                <py-repl>
                    def square_number(number):
                        return number * number 
                    # Here you see the keyword return, it is used for exiting the function. So whenever 
                    # you exit function and it's not void(empty), it should assign a value to it's variable.
                    # Let's see!

                    square_number_result = square_number(5)
                    
                    # The result of the function is transferred to the 'square_number_result' variable.
                    # This is the returned "things" from inside of the function.

                    square_number_result
                </py-repl>
                <br>
                <br>
                <p>Classes and objects:</p>
                <p>Classes and objects are again, pretty useful when it comes to reusing the code. 
                    This is at the heart of the Object Oriented Programming or OOP. There are four pillars 
                    of OOP:
                    <br>
                    <br>
                    1. Inheritance: for example you could have a base class Person. They have name and phone number.
                        We then could use this class for the base of some other class, let's say Teacher. The teacher 
                        uses the name and the phone number from the Person class and adds his individual characteristics
                        as well. This is inheritance in a nutshell.
                    <br>
                    <br>
                    2. Encapsulation: it's used for preventing self inflicted mistake or whenever someone is changing 
                        the functionality of some code that you wrote. It's achieved by using a certain keywords, such as:
                            private, protected, internal and so on.
                            2.1 Private: It can be used in front of a variable and restrict it's use to the scope of the class
                                it's in.
                            2.2 Protected: It has the upper mentioned functionality of private, with the exception that
                                it can be accessed by inherited members.
                            2.3 Internal: It is a variable that could be accessed from the current assembly we're in. Cannot be 
                                accessed by another assembly.
                    <br>
                    <br>
                    3. Polymorphism: it's in the name. Poly means many and morph means forms. It means that
                        the behavior of one class could turn out to be something different in another class.
                        For example, if we have a base class Animal and inside it we have just one method: MakeSound().
                        We then inherit the Animal class to a Dog class and a Cat class. We know that dogs and cats are 
                        different and this will reflect in the code as well. Whenever we call MakeSound() from either 
                        the dog or the cat, it has different implementation from the base class, thus changing its' behavior.
                    <br>
                    <br>
                    4. Abstraction: it's essentially hiding the complex part of the code behind something simple.
                </p>
                <br>
                <br>
                <p>Inheritance example</p>
                <py-repl>
                    class Person:
                        def __init__(self, name, number):
                            self.name = name
                            self.number = number 
                    
                        def print_name(self):
                            return self.name + " " + str(self.number)
                    
                    class Teacher(Person):
                        pass
                    
                    teacher = Teacher("ivan", 445)
                    result = teacher.print_name()
                    #This is a simple inheritance example
                    result
                </py-repl>
                <br>
                <br>
                <br>
                <p>Encapsulation example:</p>
                <py-repl>
                    class MyClass:
                        def __init__(self):
                            pass
                        def _private_method(self):
                            return "this is private"
        
                        def public_method(self):
                            return "this is public"
                    my_class = MyClass()
                    result = ""
                    result = my_class.public_method()
                    #If I call the _private_method() it will result in exception
                    result
                </py-repl>
                <br>
                <br>
                <br>
                <p>Polymorhpism example:</p>
                <br>
                <py-repl>
                    class Animal:
                        def __init__(self):
                            pass
                        def make_noise(self):
                            return "animal noise"
                    
                    class Dog(Animal):
                        def __init__(self):
                            pass
                        def make_noise(self):
                            return "dog noise"
                    
                    class Cat(Animal):
                        def __init__(self):
                            pass
                        def make_noise(self):
                            return "cat noise"
                    
                    animal = Animal()
                    dog = Dog()
                    cat = Cat()
                    animal.make_noise() + " ", dog.make_noise() + " ", cat.make_noise() 
                </py-repl>
                <br>
                <br>
                <br>
                <p>Abstraction example:</p>
                <py-repl>
                    class Car:
                        def __init__(self):
                            pass
                        def start_car():
                            def put_key():
                                pass 
                            def ignition():
                                pass 
                            def exhaust_gases():
                                pass
                            def wheel():
                                pass
                </py-repl>
                <p>As you can see there are many things behind the starting of the car.
                    They can be hidden behind a start_car() methid for example.
                </p>
                <br>
                <br>
                <h3>This concludes the 'Getting started' part for now.</h3>
                <button onclick="navigateTo()" style="background-color: green;">Next chapter: </button>
            </div>
        </div>
    </div>
    <script>
        function navigateTo() {
            window.location.href = "numpy.html"
        }
    </script>
</body>